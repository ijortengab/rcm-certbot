#!/bin/bash

# Common Functions.
red() { echo -ne "\e[91m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
green() { echo -ne "\e[92m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
yellow() { echo -ne "\e[93m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
blue() { echo -ne "\e[94m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
magenta() { echo -ne "\e[95m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
error() { echo -n "$INDENT" >&2; red '#' "$@" >&2; echo >&2; }
success() { echo -n "$INDENT" >&2; green '#' "$@" >&2; echo >&2; }
chapter() { echo -n "$INDENT" >&2; yellow '#' "$@" >&2; echo >&2; }
title() { echo -n "$INDENT" >&2; blue '#' "$@" >&2; echo >&2; }
code() { echo -n "$INDENT" >&2; magenta "$@" >&2; echo >&2; }
x() { echo >&2; exit 1; }
e() { echo -n "$INDENT" >&2; echo -n "$@" >&2; }
_() { echo -n "$INDENT" >&2; echo -n "#"' ' >&2; [ -n "$1" ] && echo -n "$@" >&2; }
_,() { echo -n "$@" >&2; }
_.() { echo >&2; }
__() { echo -n "$INDENT" >&2; echo -n "# ${RCM_INDENT}" >&2; [ -n "$1" ] && echo "$@" >&2; }
___() { echo -n "$INDENT" >&2; echo -n "# ${RCM_INDENT}${RCM_INDENT}" >&2; [ -n "$1" ] && echo "$@" >&2 || echo -n  >&2; }
____() { echo >&2; [ -n "$RCM_DELAY" ] && sleep "$RCM_DELAY"; }
----() { echo -n "$RCM_INDENT"; }

# Parse arguments. Generated by parse-options.sh
_new_arguments=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help) help=1; shift ;;
        --version) version=1; shift ;;
        --fast) fast=1; shift ;;
        --[^-]*) shift ;;
        tls-export-variables|helper)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    *) _new_arguments+=("$1"); shift ;;
                esac
            done
            ;;
        *) _new_arguments+=("$1"); shift ;;
    esac
done
set -- "${_new_arguments[@]}"
unset _new_arguments

# Command.
if [ -n "$1" ];then
    command=
    case "$1" in
        prepare) command="$1"; shift ;;
        install) command="$1"; shift ;;
        certbot) command="$1"; shift ;;
        tls-export-variables) command="$1"; shift ;;
        helper) command="$1"; shift ;;
    esac
    if [ -z "$command" ];then
        error Command unknown: '`'"$1"'`'.; x
    fi
fi

# Parse arguments per command. Generated by parse-options.sh
case "$command" in
    tls-export-variables)
        _new_arguments=()
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --help) help=1; shift ;;
                --version) version=1; shift ;;
                --certbot-certificate-name=*) certbot_certificate_name="${1#*=}"; shift ;;
                --certbot-certificate-name) if [[ ! $2 == "" && ! $2 =~ (^--$|^-[^-]|^--[^-]) ]]; then certbot_certificate_name="$2"; shift; fi; shift ;;
                --certbot-dns-plugin=*) certbot_dns_plugin="${1#*=}"; shift ;;
                --certbot-dns-plugin) if [[ ! $2 == "" && ! $2 =~ (^--$|^-[^-]|^--[^-]) ]]; then certbot_dns_plugin="$2"; shift; fi; shift ;;
                --fast) fast=1; shift ;;
                --[^-]*) shift ;;
                *) _new_arguments+=("$1"); shift ;;
            esac
        done
        set -- "${_new_arguments[@]}"
        unset _new_arguments
esac

# Define variables and constants.
[ -z "$fast" ] && fast="$RCM_FAST"; [ "$fast" == 0 ] && fast=
RCM_DELAY=${RCM_DELAY:=.5}; [ -n "$fast" ] && unset RCM_DELAY
RCM_INDENT='    '; [ "$(tput cols)" -le 80 ] && RCM_INDENT='  '
[ -z "$fast" ] && isfast='' || isfast=' --fast'
if [ -n "$RCM_VERBOSE" ];then
    verbose="$RCM_VERBOSE"
fi
[[ -z "$verbose" || "$verbose" -lt 1 ]] && quiet=1 || quiet=
[[ "$verbose" -gt 0 ]] && loud=1
[[ "$verbose" -gt 1 ]] && loud=1 && louder=1
[[ "$verbose" -gt 2 ]] && loud=1 && louder=1 && debug=1

# Functions.
printVersion() {
    echo '0.9.22'
}
printHelp() {
    title ISPConfig Setup
    _ 'Mode '; yellow init; _, .; _.
    _ 'Version '; yellow `printVersion`; _.
    _.
    cat << EOF
Usage: rcm-certbot-tls-plugin [command] [options]

Available commands: tls-export-variables.

Options for command tls-export-variables:
   --certbot-certificate-name
        Use the existing certificate name that issued by Let's encrypt or set a
        new name of certificate that to be obtained.
        Prepopulate value from variable CERTBOT_CERTIFICATE_NAME.
        Left blank will use auto set by certbot, usually the FQDN (with an integer suffix in case of conflict).
   --certbot-dns-plugin
        Select how to authenticate domain.
        Values available from command: rcm-plugin(list --interface=certbot_dns).
        Prepopulate value from variable CERTBOT_DNS_PLUGIN.

Global Options.
   --fast
        No delay every subtask.
   --version
        Print version of this script.
   --help
        Show this help.

RCM Config:
   --no-timer
   --no-confirmation

Dependency:
   rcm:0.16.25
   rcm-certbot-digitalocean-autoinstaller:`printVersion`
   rcm-certbot-obtain-authenticator-digitalocean:`printVersion`

Methods tls interface:
   prompt: rcm(certbot-tls-plugin tls-export-variables)
   prepare: rcm-certbot-tls-plugin(prepare)
   install: rcm-certbot-tls-plugin(helper install)
   obtain-certificate: rcm-certbot-tls-plugin(helper obtain-certificate)

Pre Prompt:
   rcm-plugin(init --interface=certbot_dns)

Pre Execute for command tls-export-variables:
   rcm-certbot-tls-plugin(helper certbot-dns-plugin-prompt [--certbot-dns-plugin])
EOF
}

# Help and Version.
[ -n "$help" ] && { printHelp; exit 1; }
[ -n "$version" ] && { printVersion; exit 1; }

# Functions.
isFileExists() {
    # global used:
    # global modified: found, notfound
    # function used: __
    found=
    notfound=
    if [ -f "$1" ];then
        __ File '`'$(basename "$1")'`' ditemukan.
        found=1
    else
        __ File '`'$(basename "$1")'`' tidak ditemukan.
        notfound=1
    fi
}
ArraySearch() {
    local index match="$1"
    local source=("${!2}")
    for index in "${!source[@]}"; do
       if [[ "${source[$index]}" == "${match}" ]]; then
           _return=$index; return 0
       fi
    done
    return 1
}
Rcm_certbot() {
    # Global, untuk debug.
    local certbot_request line cache_file_basename
    local start end runtime line_number
    local expired="$1"
    local url="$2"
    local table=$HOME/.cache/rcm/rcm.table.cache
    local table_lock=$HOME/.cache/rcm/rcm.table.cache.lock
    local cache_file=
    local do_delete_record_cache_file=
    _Rcm_certbot() {
        if [ -f "$table" ];then
            # todo, cek jika multiline.
            line=$(grep -n -F "$url"' ' "$table")
            if [ -z "$line" ];then
                certbot_request=1
            else
                cache_file_basename=$(cut -d' ' -f2 <<< "$line")
                cache_file=$HOME/.cache/rcm/"$cache_file_basename"
            fi
        else
            certbot_request=1
        fi
        if [ -n "$cache_file" ];then
            if [ -f "$cache_file" ];then
                if [ -s "$cache_file" ];then
                    start=`date -r "$cache_file" +'%s'`
                    end=`date +%s`
                    runtime=$((end-start))
                    if [ $runtime -gt $expired ];then
                        do_delete_record_cache_file=1
                    fi
                else
                    do_delete_record_cache_file=1
                fi
            else
                do_delete_record_cache_file=1
            fi
        fi
        if [ -n "$do_delete_record_cache_file" ];then
            line_number=$(cut -d':' -f1 <<< "$line")
            sed -i $line_number'd' "$table"
            certbot_request=1
            if [ -f "$cache_file" ];then
                rm "$cache_file"
            fi
            cache_file=
        fi
        exit_code=0
        if [ -n "$certbot_request" ];then
            mkdir -p $HOME/.cache/rcm
            cache_file=$(mktemp --tmpdir=$HOME/.cache/rcm rcm.certbot.XXXXXXXXXXXX.cache)
            cache_file_basename=$(basename "$cache_file")
            certificate_name=$(sed 's|certbot://||' <<< "$url")
            msg='Another instance of Certbot is already running.'
            while true; do
                certbot certificates --cert-name="$certificate_name" 2>/dev/null > "$cache_file"
                exit_code=$?
                if [[ $(head -1 "$cache_file") == "$msg" ]];then
                    e Retrying...; _.
                    code sleep 3
                    sleep 3
                else
                    break
                fi
            done
            mkdir -p $(dirname "$table")
            echo "$url" "$cache_file_basename" >> "$table"
        fi
    }
    until [[ ! -e "$table_lock" ]];do
        sleep .1
        # Jika lebih dari 1 menit, maka hapus saja.
        start=`date -r "$table_lock" +'%s'`
        end=`date +%s`
        runtime=$((end-start))
        if [ $runtime -gt 60 ];then
            rm "$table_lock"
        fi
    done
    touch "$table_lock"
    _Rcm_certbot
    rm "$table_lock"
    if [ ! -f "$cache_file" ];then
        exit $exit_code
    fi
    if [ ! $exit_code -eq 0 ];then
        exit $exit_code
    fi
    cat "$cache_file"
}
command-tls-export-variables() {
    # If not set in argument, try load from environment.
    [ -z "$certbot_certificate_name" ] && certbot_certificate_name="$CERTBOT_CERTIFICATE_NAME"
    # Export.
    echo 'CERTBOT_CERTIFICATE_NAME='"$certbot_certificate_name"
    # Plugin certbot_dns juga perlu di cetak, termasuk init nya, dan prompt nya.
    if [ -n "$certbot_dns_plugin" ];then
        rcm-plugin init --interface=certbot_dns 2>/dev/null
        echo 'CERTBOT_DNS_PLUGIN='"$certbot_dns_plugin"
        RCM_RESOLVE_DEPENDENCIES=0 rcm-certbot-tls-plugin $isfast helper certbot-dns-plugin-prompt "$certbot_dns_plugin" 2>/dev/null
    fi
    echo CERTBOT_DNS_PLUGIN="$certbot_dns_plugin"
}
command-prepare() {
    local domain="$RCM_DOMAIN"
    local hostname="$RCM_HOSTNAME"
    local fqdn="${hostname}.${domain}"
    local ip_address="$RCM_IP_ADDRESS"
    chapter Mengecek Name Server Domain '`'$domain'`'
    # code dig NS $domain +trace
    # stdout=$(dig NS $domain +trace)
    code dig NS $domain
    stdout=$(dig NS $domain)
    [ -n "$debug" ] && { while IFS= read -r line; do e "$line"; _.; done <<< "$stdout" ; _. ; }
    found=
    if grep -q --ignore-case 'ns.\.digitalocean\.com\.' <<< "$stdout";then
        found=1
    fi
    if [ -n "$found" ];then
        code dig NS $domain +short
        stdout=$(dig NS $domain +short)
        while IFS= read -r line; do e "$line"; _.; done <<< "$stdout" ; _. ;
        if grep -q --ignore-case 'ns.\.digitalocean\.com\.' <<< "$stdout";then
            __ Name Server pada Domain "$domain" sudah mengarah ke DigitalOcean.
        else
            __ Name Server pada Domain "$domain" belum mengarah ke DigitalOcean.
        fi
    else
        error Name Server pada Domain "$domain" tidak mengarah ke DigitalOcean.
        _ Memerlukan manual edit pada registrar domain.; x; _.
    fi
    ____

    INDENT+="$RCM_INDENT" \
    rcm-digitalocean-api-manage-domain $isfast \
        add \
        --domain="$domain" \
        --ip-address="$ip_address" \
        && INDENT+="$RCM_INDENT" \
    rcm-digitalocean-api-manage-domain-record $isfast --digitalocean-domain-exists-sure \
        add \
        --domain="$fqdn" \
        --type=a \
        --ip-address="$ip_address" \
        --hostname=@
    # Contoh Output:
    # curl https://api.digitalocean.com/v2/domains/systemix.id
    # {
        # "id": "not_found",
        # "message": "The resource you were accessing could not be found.",
        # "request_id": "cd6cb14c-cf30-41f0-bc4a-10ef6948bfe3"
    # }
    # curl -X POST -d '{"name":"systemix.id","ip_address":"203.194.114.212"}' https://api.digitalocean.com/v2/domains/
    # {
        # "domain": {
            # "name": "systemix.id",
            # "ttl": 1800,
            # "zone_file": ""
        # }
    # }
}
command-helper() {
    local helper=$1; shift
    if [ "$helper" == skip ];then
        return
    fi
    if [ -n "$helper" ];then
        if [[ $(type -t "helper-${helper}") == function ]];then
            helper-${helper} "$@"
            exit 0
        else
            error Helper unknown: '`'"$helper"'`'.; x
        fi
    fi
}
helper-certbot-dns-plugin-prompt() {
    local certbot_dns_plugin=$1
    [ "$certbot_dns_plugin" == - ] && certbot_dns_plugin=
    if [ -n "$certbot_dns_plugin" ];then
        INDENT+='    ' \
        rcm-plugin $isfast execute --interface=certbot_dns --name="$certbot_dns_plugin" \
            --method='prompt' \
            ; [ ! $? -eq 0 ] && x
    fi
}
helper-install() {
    title rcm-certbot-tls-plugin -- helper -- install
    ____

    INDENT+='    ' \
    rcm-certbot-apt $isfast \
    ; [ ! $? -eq 0 ] && x

    # If not set in argument, try load from environment.
    [ -z "$certbot_dns_plugin" ] && certbot_dns_plugin="$CERTBOT_DNS_PLUGIN"

    # Cleaning environment variable from rcm.
    [ "$certbot_dns_plugin" == - ] && certbot_dns_plugin=
    if [ -n "$certbot_dns_plugin" ];then
        INDENT+='    ' \
        rcm-plugin $isfast execute --interface=certbot_dns --name="$certbot_dns_plugin" --method='install' \
        ; [ ! $? -eq 0 ] && x
    fi
}
helper-obtain-certificate() {
    title rcm-certbot-tls-plugin -- helper -- obtain-certificate
    ____

    # Load from environment.
    [ -n "$RCM_FQDN" ] || { error Environment Variable RCM_FQDN required; x; }
    local fqdn="$RCM_FQDN"
    local certificate_name="$CERTBOT_CERTIFICATE_NAME"
    local dns_plugin="$CERTBOT_DNS_PLUGIN"

    # Cleaning environment variable from rcm.
    [ "$certificate_name" == - ] && certificate_name=

    chapter Dump variable.
    code 'fqdn="'$fqdn'"'
    code 'certificate_name="'$certificate_name'"'
    [ -z "$certificate_name" ] && certificate_name="$fqdn"
    code 'certificate_name="'$certificate_name'"'
    ____

    chapter Mengecek certificate '`'$certificate_name'`'.

    if [ -z "$tempfile" ];then
        tempfile=$(mktemp -p /dev/shm -t rcm-ispconfig-setup-smtpd-certificate.XXXXXX)
    fi
    Rcm_certbot 600 "certbot://${certificate_name}" > "$tempfile"
    certificate_path=$(cat "$tempfile" | grep -i -E 'Certificate Path:\s+' | sed -E 's/Certificate Path:\s+(.*)/\1/' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    private_key_path=$(cat "$tempfile" | grep -i -E 'Private Key Path:\s+' | sed -E 's/Private Key Path:\s+(.*)/\1/' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    code 'certificate_path="'$certificate_path'"'
    code 'private_key_path="'$private_key_path'"'
    binary=
    notfound=1
    [ -n "$certificate_path" ] && isFileExists "$certificate_path"
    [ -n "$notfound" ] && binary+=0
    notfound=1
    [ -n "$private_key_path" ] && isFileExists "$private_key_path"
    [ -n "$notfound" ] && binary+=0
    ____

    if [[ "$binary" =~ 0 ]];then
        INDENT+='    ' \
        rcm-certbot-obtain $isfast \
            --certificate-name="$certificate_name" \
            --domain="$fqdn" \
            --dns-plugin="$dns_plugin" \
            ; [ ! $? -eq 0 ] && x
    fi

    # Certificate ditemukan, maka berikutnya kita perlu verifikasi lagi.
    chapter Verifikasi Domain
    _list_domain=$(cat "$tempfile" | grep -i -E 'Domains:\s+' | sed -E 's/Domains:(.*)/\1/')
    # Jika variable $_list_domain terdapat karakter wildcard, maka:
    # list_domain=($_list_domain)
    read -ra list_domain -d '' <<< "$_list_domain"
    # Dump array dengan single quote.
    e; magenta 'list_domain=('
    first=1
    for each in "${list_domain[@]}";do
        if [ -n "$first" ];then
            magenta "'""$each""'"; first=
        else
            magenta " '""$each""'";
        fi
    done
    magenta ')'; _.
    __ Mengecek domain '`'"$fqdn"'`'
    found=
    if ArraySearch "$fqdn" list_domain[@];then
        found=1
        __ Domain ditemukan.
    else
        __ Domain tidak ditemukan.
    fi
    if [ -z "$found" ];then
        __ Mengecek versi wildcard dari domain '`'"$fqdn"'`'
        IFS='.' read -ra array <<< "$fqdn"
        if [ "${#array[@]}" -gt 2 ];then
            domain_wildcard=
            first=1
            for each in "${array[@]}"; do
                if [ -n "$first" ];then
                    domain_wildcard='*'
                    first=
                else
                    domain_wildcard+=".${each}"
                fi
            done
            code 'domain_wildcard="'$domain_wildcard'"'
            if ArraySearch "$domain_wildcard" list_domain[@];then
                found=1
                __ Wildcard domain ditemukan.
            else
                __ Wildcard domain tidak ditemukan.
            fi

        else
            __ Domain bukan merupakan subdomain.
        fi
    fi

    if [ -z "$found" ];then
        e; red Coming Soon; _.
        # pake function aja
        return
    fi

    __ Domain terdaftar pada certificate.
    certificate_path=$(cat "$tempfile" | grep -i -E 'Certificate Path:\s+' | sed -E 's/Certificate Path:\s+(.*)/\1/' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    private_key_path=$(cat "$tempfile" | grep -i -E 'Private Key Path:\s+' | sed -E 's/Private Key Path:\s+(.*)/\1/' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    ____

    echo 'NGINX_SSL_CERTIFICATE='"$certificate_path"
    echo 'NGINX_SSL_CERTIFICATE_KEY='"$private_key_path"
    # INDENT+=`----` \
        # PATH=$PATH \
        # rcm-certbot-obtain-authenticator-nginx $isfast \
            # --domain="$fqdn" \
            # --certificate-name="$certificate_name" \
            # ; [ ! $? -eq 0 ] && x
    # ____

    # e '"$fqdn"' "$fqdn";_.
    # e okey; _.

    # return
    # chapter Mengecek '$PATH'.
    # code PATH="$PATH"
    # if grep -q '/snap/bin' <<< "$PATH";then
        # __ '$PATH' sudah lengkap.
    # else
        # __ '$PATH' belum lengkap.
        # __ Memperbaiki '$PATH'
        # PATH=/snap/bin:$PATH
        # if grep -q '/snap/bin' <<< "$PATH";then
            # __; green '$PATH' sudah lengkap.; _.
            # __; magenta PATH="$PATH"; _.
        # else
            # __; red '$PATH' belum lengkap.; x
        # fi
    # fi
    # ____

    # local mode="$1"; shift
    # local domain="$RCM_DOMAIN"
    # local hostname="$RCM_HOSTNAME"
    # local certificate_name="$RCM_CERTIFICATE_NAME"
    # local fqdn="${hostname}.${domain}"
    # case "$mode" in
        # obtain)
            # INDENT+="$RCM_INDENT" \
            # PATH=$PATH \
            # rcm-certbot-obtain-authenticator-digitalocean $isfast \
                # --certbot-dns-digitalocean-sure \
                # --certificate-name="$certificate_name" \
                # --domain="$fqdn" \
                # ; [ ! $? -eq 0 ] && x
            # ;;
    # esac
}

# Execute command.
if [ -n "$command" ];then
    if [[ $(type -t "command-${command}") == function ]];then
        command-${command} "$@"
        exit 0
    else
        error Command unknown: '`'"$command"'`'.; x
    fi
fi

printHelp >/dev/null | head -3
_ Try; blue ' 'rcm-certbot-tls-plugin; magenta ' '--help; _, ' 'for more information.; _.

# parse-options.sh \
# --without-end-options-double-dash \
# --with-end-options-specific-operand \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# --fast
# --version
# --help
# )
# VALUE=(
# )
# MULTIVALUE=(
# )
# FLAG_VALUE=(
# )
# CSV=(
# )
# OPERAND=(
# tls-export-variables
# helper
# )
# EOF
# clear

# parse-options.sh \
# --without-end-options-double-dash \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# --fast
# --version
# --help
# )
# VALUE=(
# --certbot-certificate-name
# --certbot-dns-plugin
# )
# MULTIVALUE=(
# )
# FLAG_VALUE=(
# )
# CSV=(
# )
# EOF
# clear
